<html>
<title>Digital Logic Simulator</title>
<script>

var grid_status = 1; 		/* boolean status of stage grid lines 			*/
var grid_size = 50;		/* this is stored here for reference 			*/
var canvas;			/* object id of canvas tag 				*/
var ctx;			/* context of canvas					*/
var item_selected = "gate_and" 	/* only one type of object can be drawn at a time 	*/
var color_on = "#f00";		/* color of objects in high state			*/
var color_off = "#000";		/* color of objects in low state			*/

var out = new Array();		/* output bits		 				*/

/* create new output - only called during init phase */
function output(value, xpos, ypos)
{
	this.val = value;
	this.xpos = xpos;
	this.ypos = ypos;
}

/* flip bit of specified output and redraw on screen */
function output_flip(v)
{
	if(v == 'undefined') { alert("Cannot flip unknown value"); }
	if(out[v].val == 0) { out[v].val = 1; } else { out[v].val = 0; }
	// redraw output on screen
	 draw_output_simple(v);
}

/* reset all outputs to zero and redraw on screen */
function output_reset()
{
	for(var i = 0; i < 9; i++) {
		out[i].val = 0;
		// redraw outputs on screen
		draw_output_simple(i);
	}
}

/* converts decimal degrees to radians */
function deg_to_rad(deg)
{
	return (Math.PI/180)*deg;
}

/* create all output data structures and draw inital values on screen */
function init_outputs()
{
	for(var x = 0; x < 9; x++) {
		out[x] = new output(0,15,x+2);
		draw_output(15,x+2, x, 0);
	}
}

/* intial setup of page - must be called on page load */
function init_form()
{
	var x; var y;
	/* initalize canvas element for use */
	canvas = document.getElementById("stage");
	ctx = canvas.getContext("2d");
	/* get width and height of window and set stage (canvas) with it. */
	canvas.height = window.innerHeight-125;
	canvas.width = window.innerWidth - 45;
	init_outputs();
	if(grid_status) {draw_grid(); }
	/* temporary */
	draw_and_gate(1,0);
	draw_not_gate(4,0);
	draw_or_gate(7,0);
	draw_nor_gate(11,0);
	draw_xor_gate(1,3);
	draw_nand_gate(4,3);
	draw_clock(0,0,1);
	draw_clock(0,1,0);

	/* init inputs */
	for(y = "A", x = 2; x < 9; x++, y = String.fromCharCode(y.charCodeAt() + 1)) {
		draw_input(0,x, y);
	}
}

function draw_clock(x,y,phase)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	if(phase > 1 || phase < 0) { alert("Clock phase not sent"); return ; }
	x = (x*grid_size) + (grid_size/2); /* offset from conrner of grid */
	y = (y*grid_size) + (grid_size/2);
	ctx.strokeStyle = "#f33";
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.arc(x,y,20, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();
	ctx.font = "10pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText("CLK", x, y);
	/* draw line over text */
	if(phase == 0) {
		ctx.strokeStyle = "#000";
		ctx.moveTo(x,y);
		ctx.beginPath();
		ctx.lineTo(x-15,y-8);
		ctx.lineTo(x+15,y-8);
		ctx.stroke();
	}
}

/* inputs have are represented by a character with a parameter v */
function draw_input(x,y,v)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	x = (x*grid_size) + (grid_size/2); /* offset from corner of grid */
	y = (y*grid_size) + (grid_size/2);
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(v, x, y);
}

/* draw round output button.

x = grid position on x axis.
y = grid position on y axis.
v = char to print inside button.
s = state of output (on or off)
*/
function draw_output(x,y,v,s)
{
	var w = 30; /* width of box */
	var tx = x; var ty = y;
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }

	tx = x * grid_size + (grid_size / 2);
	ty = y * grid_size + (grid_size / 2);

	
	x = (x * grid_size) + (grid_size / 5); /* offset from corner of grid */
	y = (y * grid_size) + (grid_size / 5);

	/* draw filled box around char */
	if(s) { ctx.fillStyle = color_on } else { ctx.fillStyle = color_off; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.fill();

	/* draw outline box around char */
	if(s) { ctx.strokeStyle = color_off } else { ctx.strokeStyle = color_on; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();

	/* draw char inside box */
	if(s) { ctx.fillStyle = color_off; } else { ctx.fillStyle = color_on; }
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(v, tx, ty);

}

/* simple version with auto lookup to data structure */
function draw_output_simple(v)
{
	if(v == 'undefined') { alert("Cannot modify unknown output"); }
	draw_output(out[v].xpos, out[v].ypos, v, out[v].val);
}

/* draw faint gridlines on stage - used as a guide for the user */
function draw_grid()
{
	var x, y; /* current x and y position */
	var offset = 10; /* x and y maximum offset (far bottom or side of the window) */
	ctx.strokeStyle = "#ccc";
	ctx.lineWidth = 1;
	/* draw vertical lines */
	for(x = grid_size, y = 0, offset = window.innerWidth; x < window.innerWidth; x = x + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x,y+offset);
		ctx.stroke();
	}
	/* draw horizontal lines */
	for(x = 0, y = grid_size, offset = window.innerWidth; y < window.innerWidth; y = y + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+offset,y);
		ctx.stroke();
	}
}

function draw_and_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
}

function draw_nand_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc( x+(w*2), y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_not_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 40; /* width of square area of gate	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	
	/* triangle */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y+(h/2));
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();

	/* nose */
	ctx.beginPath();
	ctx.arc( x+w+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_or_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

function draw_nor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc(x+(w*3)+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_xor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* extra back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w)-10, y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

/* user changes what type of gate will be drawn next */
function change_selection(sel)
{
	var button = document.getElementById(sel);
	if(!button) { alert("Cannot Find Selected Button"); return; }
	/* enable old button */
	document.getElementById(item_selected).disabled = false;
	/* disable new button */
	button.disabled = true;
	/* set variable */
	item_selected = sel;
}

</script>

<style type="text/css">

#stage {
	border: solid 1px #000;
}

</style>
<body onLoad="init_form();">

<center><h2>Digital Logic Simulator</h2></center>
<center>
<button id="gate_and" onClick='change_selection("gate_and");' disabled >AND</button>
&nbsp;&nbsp;
<button id="gate_nand"  onClick='change_selection("gate_nand");'>NAND</button>
&nbsp;&nbsp;
<button id="gate_nor"  onClick='change_selection("gate_nor");'>NOR</button>
&nbsp;&nbsp;
<button id="gate_not"  onClick='change_selection("gate_not");'>NOT</button>
&nbsp;&nbsp;
<button id="gate_or"  onClick='change_selection("gate_or");'>OR</button>
&nbsp;&nbsp;
<button id="gate_xor"  onClick='change_selection("gate_xor");'>XOR</button>
&nbsp;&nbsp;
<button id="gate_connect"  onClick='change_selection("gate_connect");'>Connect</button>
&nbsp;&nbsp;
<button id="gate_connect"  onClick='output_flip(2);'>Bit Flip</button>
</center>




<canvas id="stage" width="200" height="200">
Your browser does not support HTML5 Canvas.
</canvas>


</body>
</html>
