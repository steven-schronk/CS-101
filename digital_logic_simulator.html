<html>
<title>Digital Logic Simulator</title>
<script>

var grid_status = 1; 		/* boolean status of stage grid lines 			*/
var grid_size = 50;		/* this is stored here for reference 			*/
var canvas;			/* object id of canvas tag 				*/
var ctx;			/* context of canvas					*/
var item_selected = "gate_and" 	/* only one type of object can be drawn at a time 	*/

var color_on = "#fe0";		/* color of objects in high state			*/
var color_on_hlt = "#f90";

var color_off = "#bbb";		/* color of objects in low state			*/
var color_off_hlt = "#ddd";

var out  = new Array();		/* output bits		 				*/
var input = new Array();	/* intput bits		 				*/
var grid = new Array();		/* status of grid - all details stored here		*/

/* create new output - only called during init phase */
function output(value, xpos, ypos)
{
	this.val = value;
	this.xpos = xpos;
	this.ypos = ypos;
}

/* each square on grid has an associated block of data tied to it */
function grid(type, xpos, ypos)
{
	this.type = type; 	/* type of entity @ location 			*/
	this.value = value; 	/* many entities have a value associated 	*/
	this.xpos = xpos;	/* horiz position on grid 			*/
	this.ypos = ypos;	/* vertical position on grid 			*/
}

/* flip bit of specified input and redraw on screen */
function input_flip(v)
{
	if(v == 'undefined') { alert("Cannot flip unknown value"); }
	if(input[v].val == 0) { input[v].val = 1; } else { input[v].val = 0; }
	// redraw output on screen
	 draw_input_simple(v);
}


/* flip bit of specified output and redraw on screen */
function output_flip(v)
{
	if(v == 'undefined') { alert("Cannot flip unknown value"); }
	if(out[v].val == 0) { out[v].val = 1; } else { out[v].val = 0; }
	// redraw output on screen
	 draw_output_simple(v);
}

/* reset all outputs to zero and redraw on screen */
function output_reset()
{
	for(var i = 0; i < 9; i++) {
		out[i].val = 0;
		// redraw outputs on screen
		draw_output_simple(i);
	}
}

/* converts decimal degrees to radians */
function deg_to_rad(deg)
{
	return (Math.PI/180)*deg;
}

/* create all output data structures and draw inital values on screen */
function init_outputs()
{
	var x;

	for(x = 0; x < 9; x++) {
		out[x] = new output(0,15,x+2);
		draw_output(15,x+2, x, 0);
	}

	for(y = "A", x = 0; x < 9; x++, y = String.fromCharCode(y.charCodeAt() + 1)) {
		input[x] = new output(0,0,x+2);
		draw_input(0,x+3, y);
	}
}

/* intial setup of page - must be called on page load */
function init_form()
{
	var x; var y;
	/* initalize canvas element for use */
	canvas = document.getElementById("stage");
	ctx = canvas.getContext("2d");
	/* get width and height of window and set stage (canvas) with it. */
	canvas.height = window.innerHeight-125;
	canvas.width = window.innerWidth - 45;
	init_outputs();
	if(grid_status) {draw_grid(); }
	/* temporary */
	draw_and_gate(1,0);
	draw_not_gate(4,0);
	draw_or_gate(7,0);
	draw_nor_gate(11,0);
	draw_xor_gate(1,3);
	draw_nand_gate(4,3);
	draw_clock(0,0,1);
	draw_clock(0,1,0);
}

function draw_clock(x,y,phase)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	if(phase > 1 || phase < 0) { alert("Clock phase not sent"); return ; }
	x = (x*grid_size) + (grid_size/2); /* offset from conrner of grid */
	y = (y*grid_size) + (grid_size/2);
	ctx.strokeStyle = "#f33";
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();
	ctx.font = "10pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText("CLK", x, y);
	/* draw line over text */
	if(phase == 0) {
		ctx.strokeStyle = "#000";
		ctx.moveTo(x,y);
		ctx.beginPath();
		ctx.lineTo(x-8,y-8);
		ctx.lineTo(x+8,y-8);
		ctx.stroke();
	}
}

/* inputs have are represented by a character with a parameter v */
function draw_input(x,y,v,s)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	x = (x*grid_size) + (grid_size/2); /* offset from corner of grid */
	y = (y*grid_size) + (grid_size/2);
	if(s) { ctx.strokeStyle = color_on_hlt } else { ctx.strokeStyle = color_off; }
	if(s) { ctx.fillStyle = color_on } else { ctx.fillStyle = color_off_hlt; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	/* draw background circle */
	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.fill();

	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();

	if(s) { ctx.fillStyle = color_on_hlt } else { ctx.fillStyle = color_off; }
	/* draw character on top */
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(v, x, y);
}

/* simple version with auto lookup to data structure */
function draw_input_simple(v)
{
	var x;
	if(v == 'undefined') { alert("Cannot modify unknown output"); }
	// TODO: Make this work with lib function instead...
	switch(v) {
		case 1:
			x = "A";
			break;
		case 2:
			x = "B";
			break;
		case 3:
			x = "C";
			break;
		case 4:
			x = "D";
			break;
		case 5:
			x = "E";
			break;
		case 6:
			x = "F";
			break;
		case 7:
			x = "G";
			break;
		case 8:
			x = "H";
			break;
	};
	draw_input(input[v].xpos, input[v].ypos, x, input[v].val);
}

/* draw output button.

x = grid position on x axis.
y = grid position on y axis.
v = char to print inside button.
s = state of output (on or off)
*/
function draw_output(x,y,v,s)
{
	var w = 30; /* width of box */
	var tx = x; var ty = y;
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }

	tx = x * grid_size + (grid_size / 2);
	ty = y * grid_size + (grid_size / 2);

	
	x = (x * grid_size) + (grid_size / 5); /* offset from corner of grid */
	y = (y * grid_size) + (grid_size / 5);

	/* draw filled box around char */
	if(s) { ctx.fillStyle = color_on } else { ctx.fillStyle = color_off_hlt; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.fill();

	/* draw outline box around char */
	if(s) { ctx.strokeStyle = color_on_hlt } else { ctx.strokeStyle = color_off; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();

	/* draw char inside box */
	if(s) { ctx.fillStyle = color_on_hlt; } else { ctx.fillStyle = color_off; }
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(v, tx, ty);
}

/* simple version with auto lookup to data structure */
function draw_output_simple(v)
{
	if(v == 'undefined') { alert("Cannot modify unknown output"); }
	draw_output(out[v].xpos, out[v].ypos, v, out[v].val);
}

/* draw faint gridlines on stage - used as a guide for the user */
function draw_grid()
{
	var x, y; /* current x and y position */
	var offset = 10; /* x and y maximum offset (far bottom or side of the window) */
	ctx.strokeStyle = "#ccc";
	ctx.lineWidth = 1;
	/* draw vertical lines */
	for(x = grid_size, y = 0, offset = window.innerWidth; x < window.innerWidth; x = x + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x,y+offset);
		ctx.stroke();
	}
	/* draw horizontal lines */
	for(x = 0, y = grid_size, offset = window.innerWidth; y < window.innerWidth; y = y + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+offset,y);
		ctx.stroke();
	}
}

function draw_and_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
}

function draw_nand_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc( x+(w*2), y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_not_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 40; /* width of square area of gate	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	
	/* triangle */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y+(h/2));
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();

	/* nose */
	ctx.beginPath();
	ctx.arc( x+w+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_or_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

function draw_nor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc(x+(w*3)+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_xor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* extra back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w)-10, y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

/* user changes what type of gate will be drawn next */
function change_selection(sel)
{
	var button = document.getElementById(sel);
	if(!button) { alert("Cannot Find Selected Button"); return; }
	/* enable old button */
	document.getElementById(item_selected).disabled = false;
	/* disable new button */
	button.disabled = true;
	/* set variable */
	item_selected = sel;
}

/* returns coordinates of canvas in pixels */
function cnvs_get_coordinates(e)
{
	var x_offset = canvas.offsetLeft;
	var y_offset = canvas.offsetTop;
	if(canvas == 'undefined') { alert("Canvas parameter is undefined"); }
	x_offset = e.clientX - x_offset;
	y_offset = e.clientY - y_offset;
	document.getElementById("xycoordinates").innerHTML="Coordinates: (" + x_offset + "," + y_offset + ")";
	return [x_offset,y_offset];
}

/* canvas has been clicked find out which grid and make correct change to square if needed. */
function cnvs_clicked(e)
{
	var coords = cnvs_get_coordinates(e);
	var x_pos = Math.floor(coords[0] / grid_size);
	var y_pos = Math.floor(coords[1] / grid_size);

	alert(x_pos + " " + y_pos);

	// if an input or output, flip value


	// ...otherwise perform whatever the current selected function is
}

</script>

<style type="text/css">

#stage {
	border: solid 1px #000;
}

</style>
<body onLoad="init_form();">

<center><h2>Digital Logic Simulator</h2></center>
<center>
<button id="gate_and" onClick='change_selection("gate_and");' disabled >AND</button>
&nbsp;&nbsp;
<button id="gate_nand"  onClick='change_selection("gate_nand");'>NAND</button>
&nbsp;&nbsp;
<button id="gate_nor"  onClick='change_selection("gate_nor");'>NOR</button>
&nbsp;&nbsp;
<button id="gate_not"  onClick='change_selection("gate_not");'>NOT</button>
&nbsp;&nbsp;
<button id="gate_or"  onClick='change_selection("gate_or");'>OR</button>
&nbsp;&nbsp;
<button id="gate_xor"  onClick='change_selection("gate_xor");'>XOR</button>
&nbsp;&nbsp;
<button id="gate_connect"  onClick='change_selection("gate_connect");'>Connect</button>
&nbsp;&nbsp;
<button id="gate_connect"  onClick='input_flip(2);'>In Flip</button>
&nbsp;&nbsp;
<button id="gate_connect"  onClick='output_flip(2);'>Out Flip</button>
</center>

<div id=xycoordinates>&nbsp;</div>

<canvas id="stage" width="200" height="200" onMouseMove="cnvs_get_coordinates(event)" onClick="cnvs_clicked(event);">
Your browser does not support HTML5 Canvas.
</canvas>

</body>
</html>
