<html>
<title>Digital Logic Simulator</title>
<script>
/* DEFAULT COLOR SETTINGS */
var color_on = "#fe0";		/* color of objects in high state			*/
var color_on_hlt = "#f90";

var color_off = "#bbb";		/* color of objects in low state			*/
var color_off_hlt = "#ddd";

/* GENERAL DATA STRUCTRURES */
var stage = new Array();	/* status of stage - all details stored here		*/
var stage_rows = 0;		/* number of rows on stage				*/
var stage_cols = 0;		/* number of columns on stage				*/
var grid_status = 1; 		/* boolean status of stage grid lines 			*/
var grid_size = 50;		/* this is stored here for reference 			*/
var canvas;			/* object id of canvas tag 				*/
var ctx;			/* context of canvas					*/
var item_selected = "gate_and" 	/* only one type of object can be drawn at a time 	*/

var out  = new Array();		/* output bits		 				*/
var input = new Array();	/* intput bits		 				*/

/* each square on grid has an associated block of data tied to it */
function grid(type, value)
{
	this.type = type; 	/* type of entity @ location 			*/
	this.value = value; 	/* many entities have a value associated 	*/
	this.name = '';		/* used for inputs and outputs 			*/
}

/* flip bit of specified input and redraw on screen */
function input_flip(v)
{
	if(v == 'undefined') { alert("Cannot flip unknown value"); }
	if(input[v].val == 0) { input[v].val = 1; } else { input[v].val = 0; }
	// redraw output on screen
	 draw_input_simple(v);
}

/* flip bit of specified output and redraw on screen */
function output_flip(v)
{
	if(v == 'undefined') { alert("Cannot flip unknown value"); }
	if(out[v].val == 0) { out[v].val = 1; } else { out[v].val = 0; }
	// redraw output on screen
	 draw_output_simple(v);
}

/* reset all outputs to zero and redraw on screen */
function output_reset()
{
	for(var i = 0; i < 9; i++) {
		out[i].val = 0;
		// redraw outputs on screen
		draw_output_simple(i);
	}
}

/* converts decimal degrees to radians */
function deg_to_rad(deg)
{
	return (Math.PI/180)*deg;
}

/* create all output data structures and draw inital values on screen */
function init_stage()
{
	var x; var y;

	/* create blank grid data structure */
	for(x = 0; x < stage_cols; x++) {
		stage[x] = new Array();
		for(y = 0; y < stage_rows; y++) {
			stage[x][y] = new grid('', '');
		}
	}

	/* setup clocks */
	stage[0][0].type = "clock";
	stage[0][1].type = "clock_";

	/* setup inputs */
	for(x = 0; x < 5; x++) {
		stage[15][x+3].type = "input";
		stage[15][x+3].value = 0;
		stage[15][x+3].name = x;
	}

	/* setup outputs */
	for(y = "A", x = 0; x < 5; x++, y = String.fromCharCode(y.charCodeAt() + 1)) {
		stage[0][x+3].type = "output";
		stage[0][x+3].value = 0;
		stage[0][x+3].name = y;
	}

	/* reset all command buttons */
	item_selected = "gate_and";
	document.getElementById("gate_and").disabled = true;
	document.getElementById("gate_nand").disabled = false;
	document.getElementById("gate_nor").disabled = false;
	document.getElementById("gate_not").disabled = false;
	document.getElementById("gate_or").disabled = false;
	document.getElementById("gate_xor").disabled = false;
	document.getElementById("delete").disabled = false;
}

/*
move through each grid in stage and draw contents.
this function can be used to refresh the screen at any time.
*/
function draw_stage()
{
	var x; var y;
	/* loop through all grids on stage, drawing contents */
	for(x=0; x < stage_cols; x++) {
		for(y = 0; y < stage_rows; y++) {
			switch(stage[x][y].type) {
				case "clock":
					draw_clock(x,y,1);
					break;
				case "clock_":
					draw_clock(x,y,0);
					break;
				case "input":
					draw_input(x,y,x);
					break;
				case "output":
					draw_output(x,y,x);
					break;
			};
		}
	}

	/* draw lines (wires) connecting gates */
	
	/* update inputs */
	
	/* update outputs */
}

/* intial setup of page - must be called on page load */
function init_form()
{
	var x; var y;
	/* initalize canvas element for use */
	canvas = document.getElementById("stage");
	ctx = canvas.getContext("2d");
	/* get width and height of window and set stage (canvas) with it. */
	canvas.height = window.innerHeight-125;
	canvas.width = window.innerWidth - 45;
	if(grid_status) {draw_grid(); }
	init_stage();
	draw_stage();
}

function draw_clock(x,y,phase)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	if(phase > 1 || phase < 0) { alert("Clock phase not sent"); return ; }
	x = (x*grid_size) + (grid_size/2); /* offset from conrner of grid */
	y = (y*grid_size) + (grid_size/2);
	ctx.strokeStyle = "#f33";
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();
	ctx.font = "10pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText("CLK", x, y);
	/* draw line over text */
	if(phase == 0) {
		ctx.strokeStyle = "#000";
		ctx.moveTo(x,y);
		ctx.beginPath();
		ctx.lineTo(x-8,y-8);
		ctx.lineTo(x+8,y-8);
		ctx.stroke();
	}
}

/* inputs have are represented by a character with a parameter v */
function draw_input(x,y)
{
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	var s = stage[x][y].value;
	var name = stage[x][y].name;
	x = (x*grid_size) + (grid_size/2); /* offset from corner of grid */
	y = (y*grid_size) + (grid_size/2);
	if(s) { ctx.strokeStyle = color_on_hlt } else { ctx.strokeStyle = color_off; }
	if(s) { ctx.fillStyle = color_on } else { ctx.fillStyle = color_off_hlt; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	/* draw background circle */
	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.fill();

	ctx.beginPath();
	ctx.arc(x,y,15, deg_to_rad(360), deg_to_rad(0), false);
	ctx.stroke();

	if(s) { ctx.fillStyle = color_on_hlt } else { ctx.fillStyle = color_off; }
	/* draw character on top */
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(name, x, y);
}

/* simple version with auto lookup to data structure */
function draw_input_simple(v)
{
	var x;
	if(v == 'undefined') { alert("Cannot modify unknown output"); }
	// TODO: Make this work with lib function instead...
	switch(v) {
		case 1:
			x = "A";
			break;
		case 2:
			x = "B";
			break;
		case 3:
			x = "C";
			break;
		case 4:
			x = "D";
			break;
		case 5:
			x = "E";
			break;
		case 6:
			x = "F";
			break;
		case 7:
			x = "G";
			break;
		case 8:
			x = "H";
			break;
	};
	draw_input(input[v].xpos, input[v].ypos, x, input[v].val);
}

/* draw output button.

x = grid position on x axis.
y = grid position on y axis.
*/
function draw_output(x,y)
{
	var w = 30; /* width of box */
	var tx = x; var ty = y;
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	var s = stage[x][y].value;
	var name = stage[x][y].name;
	tx = x * grid_size + (grid_size / 2);
	ty = y * grid_size + (grid_size / 2);

	
	x = (x * grid_size) + (grid_size / 5); /* offset from corner of grid */
	y = (y * grid_size) + (grid_size / 5);

	/* draw filled box around char */
	if(s) { ctx.fillStyle = color_on } else { ctx.fillStyle = color_off_hlt; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.fill();

	/* draw outline box around char */
	if(s) { ctx.strokeStyle = color_on_hlt } else { ctx.strokeStyle = color_off; }
	ctx.lineWidth = 2;
	ctx.moveTo(x,y);
	ctx.beginPath();
	ctx.lineTo(x+w,y);
	ctx.lineTo(x+w,y+w);
	ctx.lineTo(x,y+w);
	ctx.lineTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();

	/* draw char inside box */
	if(s) { ctx.fillStyle = color_on_hlt; } else { ctx.fillStyle = color_off; }
	ctx.font = "15pt Arial";
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(name, tx, ty);
}

/* simple version with auto lookup to data structure */
function draw_output_simple(v)
{
	if(v == 'undefined') { alert("Cannot modify unknown output"); }
	draw_output(out[v].xpos, out[v].ypos, v, out[v].val);
}

/* draw faint gridlines on stage - used as a guide for the user */
function draw_grid()
{
	var x, y; /* current x and y position */
	var offset = 10; /* x and y maximum offset (far bottom or side of the window) */
	ctx.strokeStyle = "#ccc";
	ctx.lineWidth = 1;
	/* draw vertical lines */
	for(x = grid_size, y = 0, offset = window.innerWidth; x < window.innerWidth; x = x + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x,y+offset);
		ctx.stroke();
		stage_cols++;
	}
	/* draw horizontal lines */
	for(x = 0, y = grid_size, offset = window.innerWidth; y < window.innerWidth; y = y + grid_size)
	{
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+offset,y);
		ctx.stroke();
		stage_rows++;
	}
}

function draw_and_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
}

function draw_nand_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 30; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w, y);
	ctx.arc( x+w, y+(h/2), (h/2), deg_to_rad(-90), deg_to_rad(90), false);
	ctx.lineTo(x+w, y+h);
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc( x+(w*2), y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_not_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 40; /* width of square area of gate	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	
	/* triangle */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y+(h/2));
	ctx.lineTo(x,y+h);
	ctx.lineTo(x,y);
	ctx.stroke();

	/* nose */
	ctx.beginPath();
	ctx.arc( x+w+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_or_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

function draw_nor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
	/* nose */
	ctx.beginPath();
	ctx.arc(x+(w*3)+6, y+(h/2),5, deg_to_rad(0), deg_to_rad(360), false);
	ctx.stroke();
}

function draw_xor_gate(x,y)
{
	var h = 50; /* height of  square of gate 	*/ 
	var w = 21; /* width of square area of gate 	*/
	if(x == 'undefined' || y == 'undefined') { alert("Coordinates Not Sent to Function"); return; }
	if(x < 0 || y < 0) { alert("Coordinates Cannot Be Negative"); return ; }
	ctx.strokeStyle = "#11f";
	ctx.lineWidth = 3;
	ctx.lineJoin = 'bevel';
	x = 10 + (grid_size*x); /* offset from conrner of grid */
	y = 10 + (grid_size*y);
	/* back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w), y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* extra back curve - inputs */
	ctx.beginPath();
	ctx.arc(x-(2*w)-10, y +(h/2), h, deg_to_rad(-30), deg_to_rad(30), false);
	ctx.stroke();
	/* top line */
	ctx.beginPath();
	ctx.moveTo(x,y);
	ctx.lineTo(x+w,y);
	ctx.stroke();
	/* top curve */
	ctx.beginPath();
	ctx.arc(x+w, y+h, h, deg_to_rad(-90), deg_to_rad(-30), false);
	ctx.stroke();
	/* bottom line */
	ctx.beginPath();
	ctx.moveTo(x,y+h);
	ctx.lineTo(x+w,y+h);
	ctx.stroke();	
	/* bottom curve */
	ctx.beginPath();
	ctx.arc(x+w, y, h, deg_to_rad(30), deg_to_rad(90), false);
	ctx.stroke();
}

/* user changes what type of gate will be drawn next */
function change_selection(sel)
{
	var button = document.getElementById(sel);
	if(!button) { alert("Cannot Find Selected Button"); return; }
	/* enable old button */
	document.getElementById(item_selected).disabled = false;
	//alert("enabling " + item_selected);
	/* disable new button */
	button.disabled = true;
	/* set variable */
	item_selected = sel;
}

/* returns coordinates of canvas in pixels */
function cnvs_get_coordinates(e)
{
	var x_offset = canvas.offsetLeft;
	var y_offset = canvas.offsetTop;
	if(canvas == 'undefined') { alert("Canvas parameter is undefined"); }
	x_offset = e.clientX - x_offset;
	y_offset = e.clientY - y_offset;
	document.getElementById("xycoordinates").innerHTML="Coordinates: (" + x_offset + "," + y_offset + ")";
	return [x_offset,y_offset];
}

/* canvas has been clicked find out which grid and make correct change to square if needed. */
function cnvs_clicked(e)
{
	var coords = cnvs_get_coordinates(e);
	var x_pos = Math.floor(coords[0] / grid_size);
	var y_pos = Math.floor(coords[1] / grid_size);
	// if delete command, remove contents of grid
	if(item_selected == "delete") {
		// cannot allow inputs and outputs to be deleted
		if(stage[x_pos][y_pos].type == "input" || stage[x_pos][y_pos].type == "output") { return; }
		stage[x_pos][y_pos].type = "";
		draw_stage();
	}

	// if an input or output, flip value

	// ...otherwise perform whatever the current selected function is
	if(stage[x_pos][y_pos].type != "") { return; } // check for presence of an item
	switch(item_selected) {
		case "gate_and":
			stage[x_pos][y_pos].type = "and";
			draw_and_gate(x_pos,y_pos);
			break;
		case "gate_nand":
			stage[x_pos][y_pos].type = "nand";
			draw_nand_gate(x_pos,y_pos);
			break;
		case "gate_nor":
			stage[x_pos][y_pos].type = "nor";
			draw_nor_gate(x_pos,y_pos);
			break;
		case "gate_not":
			stage[x_pos][y_pos].type = "not";
			draw_not_gate(x_pos,y_pos);
			break;
		case "gate_or":
			stage[x_pos][y_pos].type = "or";
			draw_or_gate(x_pos,y_pos);
			break;
		case "gate_xor":
			stage[x_pos][y_pos].type = "xor";
			draw_xor_gate(x_pos,y_pos);
			break;
	};
}

</script>

<style type="text/css">

#stage {
	border: solid 1px #000;
}

</style>
<body onLoad="init_form();">

<center><h2>Digital Logic Simulator</h2></center>
<center>
<button type="button" id="gate_and" onClick='change_selection("gate_and");' disabled="disabled">AND</button>
&nbsp;&nbsp;
<button type="button" id="gate_nand"  onClick='change_selection("gate_nand");'>NAND</button>
&nbsp;&nbsp;
<button type="button" id="gate_nor"  onClick='change_selection("gate_nor");'>NOR</button>
&nbsp;&nbsp;
<button type="button" id="gate_not"  onClick='change_selection("gate_not");'>NOT</button>
&nbsp;&nbsp;
<button type="button" id="gate_or"  onClick='change_selection("gate_or");'>OR</button>
&nbsp;&nbsp;
<button type="button" id="gate_xor"  onClick='change_selection("gate_xor");'>XOR</button>
&nbsp;&nbsp;
<button type="button" id="delete"  onClick='change_selection("delete");'>Delete</button>
&nbsp;&nbsp;
<button type="button" id="gate_connect"  onClick='change_selection("gate_connect");'>Connect</button>
&nbsp;&nbsp;
<button type="button" id="gate_connect"  onClick='input_flip(2);'>In Flip</button>
&nbsp;&nbsp;
<button type="button" id="gate_connect"  onClick='output_flip(2);'>Out Flip</button>
</center>

<div id=xycoordinates>&nbsp;</div>

<canvas id="stage" width="200" height="200" onMouseMove="cnvs_get_coordinates(event)" onClick="cnvs_clicked(event);">
Your browser does not support HTML5 Canvas.
</canvas>

</body>
</html>
