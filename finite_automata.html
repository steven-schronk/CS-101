<html>
<title>Finite Automata</title>
<noscript>
	<b>Your browser does not support JavaScript or JavaScript is disabled.</b>
</noscript>
<script>
var PI = 3.141592654;
var TWO_PI = PI * 2;

var BLUE   = "#00f";
var GREEN  = "#0f0";
var RED    = "#f00";
var YELLOW = "#ff0";

var stage = new Array();	/* status of stage - all details stored here	*/
var store = new Array();	/* status of input 								*/

var bit_x = null;		/* location of current bit in grid				*/
var bit_y = null;		/* see above - 0,0 is top left of grid			*/

var stage_rows = 8;			/* number of rows on stage						*/
var stage_cols = 9;			/* number of columns on stage					*/
var store_bit_count = 10;	/* number of bits stored in machine				*/

var input_count = 10;		/* number of input bits							*/

var grid_status = 1; 		/* turn grid lines on and off					*/
var grid_size = 50;			/* size in pixels of grid lines - both X and Y	*/
var canvas;					/* object id of canvas tag 						*/
var canvas_input;			/* object id of input tag						*/

var ctx;					/* context of canvas							*/
var input;					/* context of input canvas						*/

/* each square on grid has an associated block of data tied to it */
function grid(type, bit, dir, col){
	this.type = type;	/* type of machine part 			*/
	this.bit  = bit;	/* data in this block - if any 		*/
	this.dir  = dir;	/* direction this item is turned 	*/
	this.col  = col;	/* color of machine part (if any)	*/ 
}

/* this is used to display all bits on all active items */
function test_types(){
	var i = 0, j = 0, k = 1, l = 2, col = 1;
	for(i = 0; i < stage_rows; i++) {
		for(j = 0; j < stage_rows; j++){
			if(k == 6) { k = 1; }
			switch(k){
				case 1: stage[i][j].type = "branch"; break;
				case 2: stage[i][j].type = "bus"; break;
				case 3: stage[i][j].type = "input"; break;
				case 4: stage[i][j].type = "output"; break;
				case 5:
					stage[i][j].type = "bitadd";
					if(col == 5) { col = 1; }
					switch(col){
						case 1: stage[i][j].col = RED;    break;
						case 2: stage[i][j].col = GREEN;  break;
						case 3: stage[i][j].col = YELLOW; break;
						case 4: stage[i][j].col = BLUE;   break;
					};
					col++;
					break;
			};
			k++;
			if(l == 5) { l = 1; }
			switch(l){
				case 1: stage[i][j].bit = RED;    break;
				case 2: stage[i][j].bit = GREEN;  break;
				case 3: stage[i][j].bit = YELLOW; break;
				case 4: stage[i][j].bit = BLUE;   break;
			};
			l++;
		}
	}
}

/* create all output data structures and draw inital values on screen */
function init_stage(){
	var x; var y;

	/* create blank grid data structure */
	for(x = 0; x < stage_cols; x++) {
		stage[x] = new Array();
		for(y = 0; y < stage_rows; y++) {
			stage[x][y] = new grid('', '', '', '');
		}
	}
	stage[5][0].type = "input";
	stage[5][1].type = "branch";

	stage[5][2].type = "bus";
	stage[5][2].dir = 1;

	stage[6][2].type = "bus";
	stage[6][2].dir = 3;
	stage[6][1].type = "bus";
	stage[6][1].dir = 2;

	stage[5][6].type = "branch";
	stage[5][7].type = "branch";
	stage[5][8].type = "output";

	stage[0][1].type = "bus";
	stage[0][1].dir = 1;
	
	stage[5][3].type = "output";
	//stage[5][3].col = "red";
	
	stage[5][4].type = "bus";
	stage[5][4].dir = 4;
	
	stage[6][4].type = "bus";
	stage[6][4].dir = 3;

	stage[6][3].type = "bus";
	stage[6][3].dir = 2;

	stage[0][2].type = "bus";
	stage[0][2].dir = 2;
	stage[0][3].type = "bus";
	stage[0][3].dir = 3;
	stage[0][4].type = "bus";
	stage[0][4].dir = 4;

	stage[5][1].type = "bus";
	stage[5][1].dir = 1;

	//test_types();
}

/* moves automata to next position */
function next_move(){
	// if input is empty - get next bit
	if(!bit_x){
		move_getbit();
	} else {
		// determine what type of machine part we are on
		switch(stage[bit_x][bit_y].type){
			case "bitadd":
				move_bitadd();
				break;
			case "branch":
				move_branch();
				break;
			case "bus":
				move_bus();
				break;
			case "input":
				move_input();
				break;
			case "output":
				move_output();
				break;
			default:
				alert("Unknown entity.");
		};
	}
}

function move_getbit(){
	stage[5][0].bit = store.shift();
	draw_tape();
	draw_tile(5,0);
	bit_x = 5; bit_y = 0;
}

function move_bitadd(){
	// TODO: temove this switch statement
	store.push(stage[bit_x][bit_y].col);
	stage[bit_x][bit_y+1].bit = stage[bit_x][bit_y].bit;
	stage[bit_x][bit_y].bit = "";
	draw_tile(bit_x,bit_y);
	draw_tile(bit_x,bit_y+1);
	draw_tape();
	bit_y++;
}

// determine which direction to move and move there
function move_branch(){
	if(stage[bit_x][bit_y].bit == BLUE){
		stage[bit_x+1][bit_y].bit = stage[bit_x][bit_y].bit;
		stage[bit_x][bit_y].bit = "";
		draw_tile(bit_x,bit_y);
		draw_tile(bit_x+1,bit_y);
		bit_x++;
	} else if (stage[bit_x][bit_y].bit == RED){
		stage[bit_x-1][bit_y].bit = stage[bit_x][bit_y].bit;
		stage[bit_x][bit_y].bit = "";
		draw_tile(bit_x,bit_y);
		draw_tile(bit_x-1,bit_y);
		bit_x--;	
	} else {
		stage[bit_x][bit_y+1].bit = stage[bit_x][bit_y].bit;
		stage[bit_x][bit_y].bit = "";
		draw_tile(bit_x,bit_y);
		draw_tile(bit_x,bit_y+1);
		bit_y++;
	}
}

function move_bus(){
	var x = 0, y = 0;
	// 1= DOWN; 2= LEFT; 3 = UP; 4 = LEFT
	switch(stage[bit_x][bit_y].dir){
		case 1:
			y++;
			break;
		case 2:
			x--;
			break;
		case 3:
			y--;
			break;
		case 4:
			x++;
			break;
		default:
			alert("Unknown bus direction.");
	};
	stage[bit_x+x][bit_y+y].bit = stage[bit_x][bit_y].bit;
	stage[bit_x][bit_y].bit = "";
	draw_tile(bit_x,bit_y);
	bit_y += y; bit_x += x;
	draw_tile(bit_x,bit_y);
}

function move_input(){
	var i, j;
	// look for entity next to input.
	// walk around clockwise until one is found
	if(stage[bit_x][bit_y+1].type){
		stage[bit_x][bit_y+1].bit = stage[bit_x][bit_y].bit;
		stage[bit_x][bit_y].bit = "";
		draw_tile(bit_x,bit_y);
		draw_tile(bit_x,bit_y+1);
		bit_y++;
	} else { alert("Cannot continue: No connection to input."); }
}

// if we are on an output, remove bit and move to an input
function move_output(){
	stage[bit_x][bit_y].bit = "";
	draw_tile(bit_x,bit_y);
	bit_x = null; bit_y = null;
}

/* set initial values for input */
function init_input(){
	store.push(RED);
	store.push(BLUE);
	store.push(YELLOW);
	store.push(GREEN);	/* add to end 		*/
	//store.unshift("red"); /* add to front 	*/
	//store.pop();	 	/* remove from end	*/
	//store.shift(); 	/* remove from front 	*/
}

/* draw faint gridlines on stage - used as a guide for the user */
function draw_grid(){
	var x, y; /* current x and y position */
	var offset = 10; /* x and y maximum offset (far bottom or side of the window) */
	ctx.strokeStyle = "#ccc";
	ctx.lineWidth = 1;
	/* draw vertical lines */
	for(x = grid_size, y = 0, offset = window.innerWidth; x < window.innerWidth; x = x + grid_size){
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x,y+offset);
		ctx.stroke();
		stage_cols++;
	}
	/* draw horizontal lines */
	for(x = 0, y = grid_size, offset = window.innerWidth; y < window.innerWidth; y = y + grid_size){
		ctx.beginPath();
		ctx.moveTo(x,y);
		ctx.lineTo(x+offset,y);
		ctx.stroke();
		stage_rows++;
	}
}

/*
move through each grid in stage and draw contents.
this function can be used to refresh the screen at any time.
*/
function draw_stage(){
	var x; var y;
	/* loop through all grids on stage, drawing contents */
	for(x=0; x < stage_cols; x++){
		for(y = 0; y < stage_rows; y++){
			draw_tile(x,y);
		}
	}
}

function init_form(){
	var x; var y;
	/* initalize canvas element for use */
	canvas = document.getElementById("stage");
	ctx = canvas.getContext("2d");

	canvas_input = document.getElementById("input");
	input = canvas_input.getContext("2d");

	/* get width and height of window and set stage (canvas) with it. */
	canvas.height = window.innerHeight-125;
	canvas.width = window.innerWidth - 45;
	if(grid_status){draw_grid(); }
	init_stage();
	draw_stage();
	init_input();
	draw_tape();
}

/* returns coordinates of canvas in pixels */
function cnvs_get_coordinates(e){
	var x_offset = canvas.offsetLeft;
	var y_offset = canvas.offsetTop;
	if(canvas == 'undefined'){ alert("Canvas parameter is undefined"); }
	x_offset = e.clientX - x_offset;
	y_offset = e.clientY - y_offset;
	document.getElementById("xycoordinates").innerHTML="Coordinates: (" + x_offset + "," + y_offset + ")";
	return [x_offset,y_offset];
}

/* move through tape and draw bits */
function draw_tape(){
	var i = 0; var x = 50;
	input.fillStyle = "#f00";
	input.clearRect(0,0,579,100);
	while(i < store.length){
			input.beginPath();
			input.fillStyle = store[i];
			input.arc(x,25,20,0,TWO_PI,0);
			input.fill();

			input.strokeStyle = "#000";
			input.lineWidth = 2;
			input.beginPath();
			input.arc(x,25,20,0,TWO_PI,0);
			input.stroke();
		x += 50;
		i++;
	}
}

/* (re)draws any map tile on grid */
function draw_tile(x,y){
	ctx.save();
	ctx.translate(grid_size * x, grid_size * y);
	switch (stage[x][y].type){
		case "bitadd":
			draw_bitadd(stage[x][y].col);
			break;
		case "branch":
			draw_branch();
			break;
		case "bus":
			draw_bus(stage[x][y].dir);
			break;
		case "input":
			draw_input();
			break;
		case "output":
			draw_output();
			break;
		default: clear_square();
	};

	if(stage[x][y].bit){ draw_bit(stage[x][y].bit); }
	ctx.restore();
}

/* draws small bit of correct color on grid */
function draw_bit(color){
	ctx.fillStyle = "#f00";
	ctx.beginPath();
	ctx.fillStyle = color;
	ctx.arc(25,25,10,0,TWO_PI,0);
	ctx.fill();

	ctx.strokeStyle = "#000";
	ctx.lineWidth = 2;
	ctx.beginPath();
	ctx.arc(25,25,10,0,TWO_PI,0);
	ctx.stroke();
}

/* draw gray square with black outline */
function draw_input(){
	ctx.lineWidth = 1;
	ctx.strokeStyle = "#000";
	ctx.strokeRect(0,0,grid_size,grid_size);
	ctx.fillStyle = "#aaa";
	ctx.fillRect(0,0,grid_size,grid_size);
}

function drawSpirograph(ctx,R,r,O){
  var x1 = R-O;
  var y1 = 0;
  var i  = 1;
  ctx.beginPath();
  ctx.moveTo(x1,y1);
  do {
    if (i>20000) break;
    var x2 = (R+r)*Math.cos(i*Math.PI/72) - (r+O)*Math.cos(((R+r)/r)*(i*Math.PI/72))
    var y2 = (R+r)*Math.sin(i*Math.PI/72) - (r+O)*Math.sin(((R+r)/r)*(i*Math.PI/72))
    ctx.lineTo(x2,y2);
    x1 = x2;
    y1 = y2;
    i++;
  } while (x2 != R-O && y2 != 0 );
  ctx.stroke();
}

function draw_output(){
	ctx.fillStyle = "#fff";
	ctx.fillRect(2,2,grid_size-2,grid_size-2); /* clear grid */

	ctx.translate(grid_size/2,grid_size/2);
	ctx.strokeStyle = "#d80";
	ctx.lineWidth = 2;
	drawSpirograph(ctx,9,2,7);
	ctx.translate(-(grid_size/2),-(grid_size/2));
}

/* a bus moves bits from one location to another */
function draw_bus(dir){
	var i = 0;

	ctx.fillStyle = "#fff";
	ctx.fillRect(2,2,grid_size-2,grid_size-2); /* clear grid */

	ctx.lineWidth = 2;
	ctx.fillStyle = "#aaa";
	ctx.strokeStyle = "#000";

	switch(dir){
		case 2:
			ctx.translate(grid_size,0);
			ctx.rotate(PI/2);
			break;
		case 3:
			ctx.translate(grid_size,grid_size);
			ctx.rotate(PI);
			break;
		case 4:
			ctx.translate(0,grid_size);
			ctx.rotate(-PI/2);
			break;
	};

	while(i < 2){
		if(i == 1) { ctx.save(); ctx.translate(0, grid_size/2); }
		ctx.beginPath();
		ctx.moveTo(0,0);
		ctx.lineTo(grid_size/2,grid_size/2);
		ctx.lineTo(grid_size,0);
		ctx.lineTo(grid_size/2,grid_size/4);
		ctx.closePath();
		ctx.fill();

		ctx.beginPath();
		ctx.moveTo(0,0);
		ctx.lineTo(grid_size/2,grid_size/2);
		ctx.lineTo(grid_size,0);
		ctx.lineTo(grid_size/2,grid_size/4);
		ctx.closePath();
		ctx.stroke();
		if(i == 1) { ctx.restore(); }
		i++;
	}
}

/* tiles branch movement of each bit */
function draw_branch(){
	/* left */
	ctx.lineWidth = 1;
	ctx.fillStyle = "#f00";
	ctx.beginPath(); 
	ctx.moveTo(0,0);
	ctx.lineTo(grid_size/2,grid_size/2);
	ctx.lineTo(0,grid_size);
	ctx.closePath();
	ctx.fill();

	 /* top */
	ctx.fillStyle = "#000";
	ctx.beginPath();
	ctx.moveTo(0,0)
	ctx.lineTo(grid_size/2,grid_size/2);
	ctx.lineTo(grid_size,0);
	ctx.closePath();
	ctx.fill();
	

	 /* right */
	ctx.fillStyle = "#00f";
	ctx.beginPath(); 
	ctx.moveTo(grid_size,0);
	ctx.lineTo(grid_size/2,grid_size/2);
	ctx.lineTo(grid_size,grid_size);
	ctx.closePath();
	ctx.fill();

	 /* bottom */
	ctx.fillStyle = "#aaa";
	ctx.beginPath();
	ctx.moveTo(0,grid_size)
	ctx.lineTo(grid_size/2,grid_size/2);
	ctx.lineTo(grid_size,grid_size);
	ctx.closePath();
	ctx.fill();	
}

function draw_bitadd(color){
	var i = 0;
	while(i < 2){
		if(i==1){
			ctx.strokeStyle = color;
			ctx.lineWidth = 10;
		} else {
			ctx.strokeStyle = "#000";
			ctx.lineWidth = 15;		
		}
		ctx.beginPath();
		ctx.moveTo(grid_size/2,0);
		ctx.lineTo(grid_size/2,grid_size);
		ctx.closePath();
		ctx.stroke();

		ctx.beginPath();
		ctx.moveTo(0, grid_size/2);
		ctx.lineTo(grid_size,grid_size/2);
		ctx.closePath();
		ctx.stroke();
		i++;
	}
	ctx.strokeStyle = "#000";
	ctx.lineWidth = 1;
	ctx.beginPath();
	ctx.moveTo(0, 0);
	ctx.lineTo(0,grid_size);
	ctx.lineTo(grid_size,grid_size);
	ctx.lineTo(grid_size,0);
	ctx.lineTo(0,0);
	ctx.closePath();
	ctx.stroke();
}

/* clear this square by setting area to white */
function clear_square(){
	ctx.fillStyle = "#fff";
	ctx.fillRect(1,1,grid_size-2,grid_size-2);
}

/* canvas has been clicked find out which grid and make correct change to square if needed. */
function cnvs_clicked(e){}

</script>

<style type="text/css">

</style>

<body onLoad="init_form();">

<div id="topsection">

<center>
<button onClick='reset();'><img src="http://opentextbook.info/icons/32x32/resultset_first.png" title="Restart" alt="Restart"></button>
&nbsp;&nbsp;
<button onClick='step_back();'><img src="http://opentextbook.info/icons/32x32/resultset_previous.png" title="Step Back" alt="Step Back"></button>
&nbsp;&nbsp;
<button onClick='next_move();'><img src="http://opentextbook.info/icons/32x32/resultset_next.png" title="Next Step" alt="Next Step"></button>
&nbsp;&nbsp;
<button onClick='run();'><img src="http://opentextbook.info/icons/32x32/resultset_last.png" title="Run" alt="Run"></button>
&nbsp;&nbsp;

<!--
<button onClick='halt();'><img src="http://opentextbook.info/icons/32x32/cancel.png" title="Halt Execution" alt="Halt Execution"></button>
&nbsp;&nbsp;

<button disabled><img src="http://opentextbook.info/icons/32x32/disk.png" title="Save Code" alt="Save Code"></button>
&nbsp;&nbsp;
<button onClick='display_docs();'><img src="http://opentextbook.info/icons/32x32/book_open.png" title="Open Documentation" alt="Open Documentation"></button>
-->
</center>

</div>

<div id="xycoordinates">Coordinates:</div>
<canvas id="input" width="579" height="100"></canvas>
<canvas id="stage" width="579" height="770" onmousemove="cnvs_get_coordinates(event)" onclick="cnvs_clicked(event);">
Your browser does not support HTML5 Canvas.
</canvas>

</body>
</html>
